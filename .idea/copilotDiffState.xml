<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="updatedContent" value="Conversion CSV -&gt; XML&#10;&#10;Ce dépôt contient un petit script Python pour convertir le fichier CSV `PADCHEST_chest_x_ray_images_labels_160K_01.02.19.csv` en un fichier XML avec la structure demandée (ImageID en attribut et balises dans l'ordre exact demandé).&#10;&#10;Comment l'utiliser (Windows, cmd.exe):&#10;&#10;1. Ouvrez une fenêtre cmd dans le dossier du projet (`C:\Users\MohammedE\Documents\nouvelle`).&#10;2. Exécutez (Python 3.6+ requis):&#10;&#10;    python scripts\csv_to_xml.py src\main\java\org\example\data\PADCHEST_chest_x_ray_images_labels_160K_01.02.19.csv src\main\java\org\example\data\PADCHEST_chest_x_ray_images_labels_160K_01.02.19.xml&#10;&#10;Le script lit le CSV en streaming, gère correctement les guillemets et écrit `images` / `image` avec `ImageID` comme attribut. Il ignore les champs vides pour ne pas créer d'éléments vides.&#10;&#10;Remarque: le projet Java contient déjà une classe `conversion_xml` qui fait une conversion similaire; si vous souhaitez l'utiliser, installez Maven et exécutez `mvn package` puis la classe Java (mais sur cette machine `mvn` n'est apparemment pas disponible). Le script Python est autonome et devrait fonctionner sans installer Maven.&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/scripts/csv_to_xml.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/scripts/csv_to_xml.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Script de conversion CSV -&gt; XML pour reproduire le format attendu (ImageID en attribut, éléments dans l'ordre demandé,&#10;nom exact des balises comme dans `PADCHEST_chest_x_ray_images_labels_160K_01.02.19.xml`).&#10;Usage (Windows cmd.exe):&#10;    python scripts\csv_to_xml.py &quot;path\to\PADCHEST_chest_x_ray_images_labels_160K_01.02.19.csv&quot; &quot;path\to\output.xml&quot;&#10;&#10;Le script lit en streaming (pour gros fichiers), gère les guillemets correctement (module csv),&#10;ignore les champs vides (ne les écrit pas), et conserve l'ordre des colonnes demandé.&#10;&quot;&quot;&quot;&#10;from __future__ import annotations&#10;import csv&#10;import sys&#10;import os&#10;import xml.sax.saxutils as sax&#10;from typing import List, Dict&#10;&#10;# Colonnes attendues (clés normalisées en minuscules) et noms de sortie exacts&#10;DESIRED_COLUMNS: List[tuple] = [&#10;    (&quot;imageid&quot;, &quot;ImageID&quot;),&#10;    (&quot;imagedir&quot;, &quot;ImageDir&quot;),&#10;    (&quot;studyid&quot;, &quot;StudyID&quot;),&#10;    (&quot;patientid&quot;, &quot;PatientID&quot;),&#10;    (&quot;patientbirth&quot;, &quot;PatientBirth&quot;),&#10;    (&quot;projection&quot;, &quot;Projection&quot;),&#10;    (&quot;pediatric&quot;, &quot;Pediatric&quot;),&#10;    (&quot;methodprojection&quot;, &quot;MethodProjection&quot;),&#10;    (&quot;reportid&quot;, &quot;ReportID&quot;),&#10;    (&quot;report&quot;, &quot;Report&quot;),&#10;    (&quot;methodlabel&quot;, &quot;MethodLabel&quot;),&#10;    (&quot;labels&quot;, &quot;Labels&quot;),&#10;    (&quot;localizations&quot;, &quot;Localizations&quot;),&#10;    (&quot;labelslocalizationsbysentence&quot;, &quot;LabelsLocalizationsBySentence&quot;),&#10;    # accepter la faute commune 'labeicuis' et normal 'labelcuis'&#10;    (&quot;labelcuis&quot;, &quot;LabeICUIS&quot;),&#10;    (&quot;labeicuis&quot;, &quot;LabeICUIS&quot;),&#10;    (&quot;localizationscuis&quot;, &quot;LocalizationsCUIS&quot;),&#10;]&#10;&#10;EXPECTED_HEADERS = {k for k, _ in DESIRED_COLUMNS}&#10;&#10;&#10;def normalize(h: str) -&gt; str:&#10;    if h is None:&#10;        return &quot;&quot;&#10;    return h.strip().lower()&#10;&#10;&#10;def build_header_index(headers: List[str]) -&gt; Dict[str, int]:&#10;    idx: Dict[str, int] = {}&#10;    for i, h in enumerate(headers):&#10;        n = normalize(h)&#10;        if n and n not in idx:&#10;            idx[n] = i&#10;    # tolérance: si header contient &quot;labeicuis&quot; correspond à labelcuis&#10;    if &quot;labeicuis&quot; in idx and &quot;labelcuis&quot; not in idx:&#10;        idx[&quot;labelcuis&quot;] = idx[&quot;labeicuis&quot;]&#10;    return idx&#10;&#10;&#10;def escape_text(s: str) -&gt; str:&#10;    # utiliser saxutils pour échapper convenablement le contenu des éléments&#10;    return sax.escape(s) if s is not None else &quot;&quot;&#10;&#10;&#10;def escape_attr(s: str) -&gt; str:&#10;    # pour attributs, échapper aussi les apostrophes si nécessaire (sax.escape ne le fait pas)&#10;    if s is None:&#10;        return &quot;&quot;&#10;    escaped = sax.escape(s)&#10;    return escaped.replace(&quot;'&quot;, &quot;&amp;apos;&quot;)&#10;&#10;&#10;def convert(csv_path: str, xml_path: str) -&gt; int:&#10;    # Vérifications basiques&#10;    if not os.path.exists(csv_path):&#10;        print(f&quot;Fichier introuvable: {csv_path}&quot;)&#10;        return 2&#10;&#10;    # Ouvrir en lecture en UTF-8 en mode texte&#10;    with open(csv_path, newline='', encoding='utf-8') as csvfile:&#10;        # détecteur dialecte basique&#10;        reader = csv.reader(csvfile)&#10;        try:&#10;            headers = next(reader)&#10;        except StopIteration:&#10;            print(&quot;CSV vide&quot;)&#10;            return 3&#10;&#10;        header_index = build_header_index(headers)&#10;&#10;        # Vérifier la présence des colonnes minimales (imageid recommandé)&#10;        missing = [h for h in EXPECTED_HEADERS if h not in header_index]&#10;        # tolérance pour labelcuis/labeicuis&#10;        if &quot;labelcuis&quot; in missing and &quot;labeicuis&quot; in header_index:&#10;            missing.remove(&quot;labelcuis&quot;)&#10;        if missing:&#10;            print(&quot;Colonnes manquantes (liste attendue partielle):&quot;, missing)&#10;            print(&quot;En-têtes trouvés:&quot;, headers)&#10;            # continuer malgré tout si l'utilisateur veut, mais on signale&#10;&#10;        # écrire en streaming le fichier XML&#10;        count = 0&#10;        with open(xml_path, 'w', encoding='utf-8', newline='') as xf:&#10;            xf.write('&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n')&#10;            xf.write('&lt;images&gt;\n')&#10;&#10;            for row in reader:&#10;                # éviter lignes vides&#10;                if not any(cell.strip() for cell in row):&#10;                    continue&#10;                # s'assurer que row a la même taille que headers&#10;                if len(row) &lt; len(headers):&#10;                    row = row + [&quot;&quot;] * (len(headers) - len(row))&#10;&#10;                imageid = &quot;&quot;&#10;                if 'imageid' in header_index:&#10;                    imageid = row[header_index['imageid']]&#10;                imageid = '' if imageid is None else imageid&#10;&#10;                xf.write(f'  &lt;image ImageID=&quot;{escape_attr(imageid)}&quot;&gt;\n')&#10;&#10;                # écrire les colonnes demandées dans l'ordre&#10;                for norm, outname in DESIRED_COLUMNS:&#10;                    if norm == 'imageid':&#10;                        continue&#10;                    idx = header_index.get(norm)&#10;                    if idx is None:&#10;                        continue&#10;                    val = row[idx]&#10;                    if val is None:&#10;                        continue&#10;                    val = val.strip()&#10;                    if val == &quot;&quot;:&#10;                        continue&#10;                    # écrire l'élément&#10;                    xf.write(f'    &lt;{outname}&gt;' + escape_text(val) + f'&lt;/{outname}&gt;\n')&#10;&#10;                xf.write('  &lt;/image&gt;\n')&#10;                count += 1&#10;                if (count % 1000) == 0:&#10;                    xf.flush()&#10;&#10;            xf.write('&lt;/images&gt;\n')&#10;&#10;    print(f&quot;Conversion terminée: {count} enregistrements écrits dans {xml_path}&quot;)&#10;    return 0&#10;&#10;&#10;if __name__ == '__main__':&#10;    if len(sys.argv) &lt; 2:&#10;        print(&quot;Usage: python scripts\\csv_to_xml.py input.csv [output.xml]&quot;)&#10;        sys.exit(1)&#10;    csv_path = sys.argv[1]&#10;    xml_path = sys.argv[2] if len(sys.argv) &gt; 2 else os.path.splitext(csv_path)[0] + '.xml'&#10;    rc = convert(csv_path, xml_path)&#10;    sys.exit(rc)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>